# Autogenerated from the HTML5 specification. Edits may be lost.
module Watir
 class HTMLElement < Element
   attribute("String", :title, "title")
   attribute("String", :lang, "lang")
   attribute("Boolean", :translate?, "translate")
   attribute("String", :dir, "dir")
   attribute("StringMap", :dataset, "dataset")
   attribute("Boolean", :item_scope?, "itemScope")
   attribute("TokenList", :item_type, "itemType")
   attribute("String", :item_id, "itemId")
   attribute("TokenList", :item_ref, "itemRef")
   attribute("TokenList", :item_prop, "itemProp")
   attribute("PropertiesCollection", :properties, "properties")
   attribute("String", :item_value, "itemValue")
   attribute("Boolean", :hidden?, "hidden")
   attribute("Boolean", :inert?, "inert")
   attribute("Fixnum", :tab_index, "tabIndex")
   attribute("String", :access_key, "accessKey")
   attribute("String", :access_key_label, "accessKeyLabel")
   attribute("Boolean", :draggable?, "draggable")
   attribute("TokenList", :dropzone, "dropzone")
   attribute("String", :content_editable, "contentEditable")
   attribute("Boolean", :content_editable?, "isContentEditable")
   attribute("HTMLElement", :context_menu, "contextMenu")
   attribute("Boolean", :spellcheck?, "spellcheck")
   attribute("String", :command_type, "commandType")
   attribute("String", :command_label, "commandLabel")
   attribute("String", :command_icon, "commandIcon")
   attribute("Boolean", :command_hidden?, "commandHidden")
   attribute("Boolean", :command_disabled?, "commandDisabled")
   attribute("Boolean", :command_checked?, "commandChecked")
   attribute("Function", :onabort, "onabort")
   attribute("Function", :onblur, "onblur")
   attribute("Function", :oncancel, "oncancel")
   attribute("Function", :oncanplay, "oncanplay")
   attribute("Function", :oncanplaythrough, "oncanplaythrough")
   attribute("Function", :onchange, "onchange")
   attribute("Function", :onclick, "onclick")
   attribute("Function", :onclose, "onclose")
   attribute("Function", :oncontextmenu, "oncontextmenu")
   attribute("Function", :oncuechange, "oncuechange")
   attribute("Function", :ondblclick, "ondblclick")
   attribute("Function", :ondrag, "ondrag")
   attribute("Function", :ondragend, "ondragend")
   attribute("Function", :ondragenter, "ondragenter")
   attribute("Function", :ondragexit, "ondragexit")
   attribute("Function", :ondragleave, "ondragleave")
   attribute("Function", :ondragover, "ondragover")
   attribute("Function", :ondragstart, "ondragstart")
   attribute("Function", :ondrop, "ondrop")
   attribute("Function", :ondurationchange, "ondurationchange")
   attribute("Function", :onemptied, "onemptied")
   attribute("Function", :onended, "onended")
   attribute("Function", :onerror, "onerror")
   attribute("Function", :onfocus, "onfocus")
   attribute("Function", :oninput, "oninput")
   attribute("Function", :oninvalid, "oninvalid")
   attribute("Function", :onkeydown, "onkeydown")
   attribute("Function", :onkeypress, "onkeypress")
   attribute("Function", :onkeyup, "onkeyup")
   attribute("Function", :onload, "onload")
   attribute("Function", :onloadeddata, "onloadeddata")
   attribute("Function", :onloadedmetadata, "onloadedmetadata")
   attribute("Function", :onloadstart, "onloadstart")
   attribute("Function", :onmousedown, "onmousedown")
   attribute("Function", :onmouseenter, "onmouseenter")
   attribute("Function", :onmouseleave, "onmouseleave")
   attribute("Function", :onmousemove, "onmousemove")
   attribute("Function", :onmouseout, "onmouseout")
   attribute("Function", :onmouseover, "onmouseover")
   attribute("Function", :onmouseup, "onmouseup")
   attribute("Function", :onmousewheel, "onmousewheel")
   attribute("Function", :onpause, "onpause")
   attribute("Function", :onplay, "onplay")
   attribute("Function", :onplaying, "onplaying")
   attribute("Function", :onprogress, "onprogress")
   attribute("Function", :onratechange, "onratechange")
   attribute("Function", :onreset, "onreset")
   attribute("Function", :onresize, "onresize")
   attribute("Function", :onscroll, "onscroll")
   attribute("Function", :onseeked, "onseeked")
   attribute("Function", :onseeking, "onseeking")
   attribute("Function", :onselect, "onselect")
   attribute("Function", :onshow, "onshow")
   attribute("Function", :onsort, "onsort")
   attribute("Function", :onstalled, "onstalled")
   attribute("Function", :onsubmit, "onsubmit")
   attribute("Function", :onsuspend, "onsuspend")
   attribute("Function", :ontimeupdate, "ontimeupdate")
   attribute("Function", :ontoggle, "ontoggle")
   attribute("Function", :onvolumechange, "onvolumechange")
   attribute("Function", :onwaiting, "onwaiting")
 end
 class HTMLElementCollection < ElementCollection
   def element_class
     HTMLElement
   end
 end
 class Font < HTMLElement
   attribute("String", :color, "color")
   attribute("String", :face, "face")
   attribute("String", :size, "size")
 end
 class FontCollection < ElementCollection
   def element_class
     Font
   end
 end
 class Directory < HTMLElement
   attribute("Boolean", :compact?, "compact")
 end
 class DirectoryCollection < ElementCollection
   def element_class
     Directory
   end
 end
 class FrameSet < HTMLElement
   attribute("String", :cols, "cols")
   attribute("String", :rows, "rows")
   attribute("Function", :onafterprint, "onafterprint")
   attribute("Function", :onbeforeprint, "onbeforeprint")
   attribute("Function", :onbeforeunload, "onbeforeunload")
   attribute("Function", :onhashchange, "onhashchange")
   attribute("Function", :onlanguagechange, "onlanguagechange")
   attribute("Function", :onmessage, "onmessage")
   attribute("Function", :onoffline, "onoffline")
   attribute("Function", :ononline, "ononline")
   attribute("Function", :onpagehide, "onpagehide")
   attribute("Function", :onpageshow, "onpageshow")
   attribute("Function", :onpopstate, "onpopstate")
   attribute("Function", :onstorage, "onstorage")
   attribute("Function", :onunload, "onunload")
 end
 class FrameSetCollection < ElementCollection
   def element_class
     FrameSet
   end
 end
 class Marquee < HTMLElement
   attribute("String", :behavior, "behavior")
   attribute("String", :bg_color, "bgColor")
   attribute("String", :direction, "direction")
   attribute("String", :height, "height")
   attribute("Fixnum", :hspace, "hspace")
   attribute("Fixnum", :loop, "loop")
   attribute("Fixnum", :scroll_amount, "scrollAmount")
   attribute("Fixnum", :scroll_delay, "scrollDelay")
   attribute("Boolean", :true_speed?, "trueSpeed")
   attribute("Fixnum", :vspace, "vspace")
   attribute("String", :width, "width")
   attribute("Function", :onbounce, "onbounce")
   attribute("Function", :onfinish, "onfinish")
   attribute("Function", :onstart, "onstart")
 end
 class MarqueeCollection < ElementCollection
   def element_class
     Marquee
   end
 end
 class Applet < HTMLElement
   attribute("String", :align, "align")
   attribute("String", :alt, "alt")
   attribute("String", :archive, "archive")
   attribute("String", :code, "code")
   attribute("String", :code_base, "codeBase")
   attribute("String", :height, "height")
   attribute("Fixnum", :hspace, "hspace")
   attribute("String", :name, "name")
   attribute("String", :object, "object")
   attribute("Fixnum", :vspace, "vspace")
   attribute("String", :width, "width")
 end
 class AppletCollection < ElementCollection
   def element_class
     Applet
   end
 end
 class Canvas < HTMLElement
   attribute("Fixnum", :width, "width")
   attribute("Fixnum", :height, "height")
 end
 class CanvasCollection < ElementCollection
   def element_class
     Canvas
   end
 end
 class Template < HTMLElement
   attribute("Document", :content, "content")
 end
 class TemplateCollection < ElementCollection
   def element_class
     Template
   end
 end
 class Script < HTMLElement
   attribute("String", :src, "src")
   attribute("String", :type, "type")
   attribute("String", :charset, "charset")
   attribute("Boolean", :async?, "async")
   attribute("Boolean", :defer?, "defer")
   attribute("String", :cross_origin, "crossOrigin")
   attribute("String", :text, "text")
 end
 class ScriptCollection < ElementCollection
   def element_class
     Script
   end
 end
 class Script < HTMLElement
   attribute("String", :event, "event")
   attribute("String", :for, "htmlFor")
 end
 # do nothing
 class Dialog < HTMLElement
   attribute("Boolean", :open?, "open")
   attribute("String", :return_value, "returnValue")
 end
 class DialogCollection < ElementCollection
   def element_class
     Dialog
   end
 end
 class MenuItem < HTMLElement
   attribute("String", :type, "type")
   attribute("String", :label, "label")
   attribute("String", :icon, "icon")
   attribute("Boolean", :disabled?, "disabled")
   attribute("Boolean", :checked?, "checked")
   attribute("String", :radiogroup, "radiogroup")
   attribute("Boolean", :default?, "default")
   attribute("HTMLElement", :command, "command")
 end
 class MenuItemCollection < ElementCollection
   def element_class
     MenuItem
   end
 end
 class Menu < HTMLElement
   attribute("String", :type, "type")
   attribute("String", :label, "label")
 end
 class MenuCollection < ElementCollection
   def element_class
     Menu
   end
 end
 class Menu < HTMLElement
   attribute("Boolean", :compact?, "compact")
 end
 # do nothing
 class Details < HTMLElement
   attribute("Boolean", :open?, "open")
 end
 class DetailsCollection < ElementCollection
   def element_class
     Details
   end
 end
 class Legend < HTMLElement
   attribute("HTMLElement", :form, "form")
 end
 class LegendCollection < ElementCollection
   def element_class
     Legend
   end
 end
 class Legend < HTMLElement
   attribute("String", :align, "align")
 end
 # do nothing
 class FieldSet < HTMLElement
   attribute("Boolean", :disabled?, "disabled")
   attribute("HTMLElement", :form, "form")
   attribute("String", :name, "name")
   attribute("String", :type, "type")
   attribute("HTMLCollection", :elements, "elements")
   attribute("Boolean", :will_validate?, "willValidate")
   attribute("String", :validity, "validity")
   attribute("String", :validation_message, "validationMessage")
 end
 class FieldSetCollection < ElementCollection
   def element_class
     FieldSet
   end
 end
 class Meter < HTMLElement
   attribute("Float", :value, "value")
   attribute("Float", :min, "min")
   attribute("Float", :max, "max")
   attribute("Float", :low, "low")
   attribute("Float", :high, "high")
   attribute("Float", :optimum, "optimum")
   attribute("List", :labels, "labels")
 end
 class MeterCollection < ElementCollection
   def element_class
     Meter
   end
 end
 class Progress < HTMLElement
   attribute("Float", :value, "value")
   attribute("Float", :max, "max")
   attribute("Float", :position, "position")
   attribute("List", :labels, "labels")
 end
 class ProgressCollection < ElementCollection
   def element_class
     Progress
   end
 end
 class Output < HTMLElement
   attribute("TokenList", :for, "htmlFor")
   attribute("HTMLElement", :form, "form")
   attribute("String", :name, "name")
   attribute("String", :type, "type")
   attribute("String", :default_value, "defaultValue")
   attribute("String", :value, "value")
   attribute("Boolean", :will_validate?, "willValidate")
   attribute("String", :validity, "validity")
   attribute("String", :validation_message, "validationMessage")
   attribute("List", :labels, "labels")
 end
 class OutputCollection < ElementCollection
   def element_class
     Output
   end
 end
 class Keygen < HTMLElement
   attribute("Boolean", :autofocus?, "autofocus")
   attribute("String", :challenge, "challenge")
   attribute("Boolean", :disabled?, "disabled")
   attribute("HTMLElement", :form, "form")
   attribute("String", :keytype, "keytype")
   attribute("String", :name, "name")
   attribute("String", :type, "type")
   attribute("Boolean", :will_validate?, "willValidate")
   attribute("String", :validity, "validity")
   attribute("String", :validation_message, "validationMessage")
   attribute("List", :labels, "labels")
 end
 class KeygenCollection < ElementCollection
   def element_class
     Keygen
   end
 end
 class TextArea < HTMLElement
   attribute("String", :autocomplete, "autocomplete")
   attribute("Boolean", :autofocus?, "autofocus")
   attribute("Fixnum", :cols, "cols")
   attribute("String", :dir_name, "dirName")
   attribute("Boolean", :disabled?, "disabled")
   attribute("HTMLElement", :form, "form")
   attribute("String", :input_mode, "inputMode")
   attribute("Fixnum", :max_length, "maxLength")
   attribute("Fixnum", :min_length, "minLength")
   attribute("String", :name, "name")
   attribute("String", :placeholder, "placeholder")
   attribute("Boolean", :read_only?, "readOnly")
   attribute("Boolean", :required?, "required")
   attribute("Fixnum", :rows, "rows")
   attribute("String", :wrap, "wrap")
   attribute("String", :type, "type")
   attribute("String", :default_value, "defaultValue")
   attribute("String", :value, "value")
   attribute("Fixnum", :text_length, "textLength")
   attribute("Boolean", :will_validate?, "willValidate")
   attribute("String", :validity, "validity")
   attribute("String", :validation_message, "validationMessage")
   attribute("List", :labels, "labels")
   attribute("Fixnum", :selection_start, "selectionStart")
   attribute("Fixnum", :selection_end, "selectionEnd")
   attribute("String", :selection_direction, "selectionDirection")
 end
 class TextAreaCollection < ElementCollection
   def element_class
     TextArea
   end
 end
 class Option < HTMLElement
   attribute("Boolean", :disabled?, "disabled")
   attribute("HTMLElement", :form, "form")
   attribute("String", :label, "label")
   attribute("Boolean", :default_selected?, "defaultSelected")
   attribute("Boolean", :selected?, "selected")
   attribute("String", :value, "value")
   attribute("String", :text, "text")
   attribute("Fixnum", :index, "index")
 end
 class OptionCollection < ElementCollection
   def element_class
     Option
   end
 end
 class OptGroup < HTMLElement
   attribute("Boolean", :disabled?, "disabled")
   attribute("String", :label, "label")
 end
 class OptGroupCollection < ElementCollection
   def element_class
     OptGroup
   end
 end
 class DataList < HTMLElement
   attribute("HTMLCollection", :options, "options")
 end
 class DataListCollection < ElementCollection
   def element_class
     DataList
   end
 end
 class Select < HTMLElement
   attribute("Boolean", :autofocus?, "autofocus")
   attribute("Boolean", :disabled?, "disabled")
   attribute("HTMLElement", :form, "form")
   attribute("Boolean", :multiple?, "multiple")
   attribute("String", :name, "name")
   attribute("Boolean", :required?, "required")
   attribute("Fixnum", :size, "size")
   attribute("String", :type, "type")
   attribute("HTMLCollection", :options, "options")
   attribute("Fixnum", :length, "length")
   attribute("HTMLCollection", :selected_options, "selectedOptions")
   attribute("Fixnum", :selected_index, "selectedIndex")
   attribute("String", :value, "value")
   attribute("Boolean", :will_validate?, "willValidate")
   attribute("String", :validity, "validity")
   attribute("String", :validation_message, "validationMessage")
   attribute("List", :labels, "labels")
 end
 class SelectCollection < ElementCollection
   def element_class
     Select
   end
 end
 class Button < HTMLElement
   attribute("Boolean", :autofocus?, "autofocus")
   attribute("Boolean", :disabled?, "disabled")
   attribute("HTMLElement", :form, "form")
   attribute("String", :form_action, "formAction")
   attribute("String", :form_enctype, "formEnctype")
   attribute("String", :form_method, "formMethod")
   attribute("Boolean", :form_no_validate?, "formNoValidate")
   attribute("String", :form_target, "formTarget")
   attribute("String", :name, "name")
   attribute("String", :type, "type")
   attribute("String", :value, "value")
   attribute("HTMLElement", :menu, "menu")
   attribute("Boolean", :will_validate?, "willValidate")
   attribute("String", :validity, "validity")
   attribute("String", :validation_message, "validationMessage")
   attribute("List", :labels, "labels")
 end
 class ButtonCollection < ElementCollection
   def element_class
     Button
   end
 end
 class Input < HTMLElement
   attribute("String", :accept, "accept")
   attribute("String", :alt, "alt")
   attribute("String", :autocomplete, "autocomplete")
   attribute("Boolean", :autofocus?, "autofocus")
   attribute("Boolean", :default_checked?, "defaultChecked")
   attribute("Boolean", :checked?, "checked")
   attribute("String", :dir_name, "dirName")
   attribute("Boolean", :disabled?, "disabled")
   attribute("HTMLElement", :form, "form")
   attribute("List", :files, "files")
   attribute("String", :form_action, "formAction")
   attribute("String", :form_enctype, "formEnctype")
   attribute("String", :form_method, "formMethod")
   attribute("Boolean", :form_no_validate?, "formNoValidate")
   attribute("String", :form_target, "formTarget")
   attribute("Fixnum", :height, "height")
   attribute("Boolean", :indeterminate?, "indeterminate")
   attribute("String", :input_mode, "inputMode")
   attribute("HTMLElement", :list, "list")
   attribute("String", :max, "max")
   attribute("Fixnum", :max_length, "maxLength")
   attribute("String", :min, "min")
   attribute("Fixnum", :min_length, "minLength")
   attribute("Boolean", :multiple?, "multiple")
   attribute("String", :name, "name")
   attribute("String", :pattern, "pattern")
   attribute("String", :placeholder, "placeholder")
   attribute("Boolean", :read_only?, "readOnly")
   attribute("Boolean", :required?, "required")
   attribute("Fixnum", :size, "size")
   attribute("String", :src, "src")
   attribute("String", :step, "step")
   attribute("String", :type, "type")
   attribute("String", :default_value, "defaultValue")
   attribute("String", :value, "value")
   attribute("Date", :value_as_date, "valueAsDate")
   attribute("Float", :value_as_number, "valueAsNumber")
   attribute("Float", :value_low, "valueLow")
   attribute("Float", :value_high, "valueHigh")
   attribute("Fixnum", :width, "width")
   attribute("Boolean", :will_validate?, "willValidate")
   attribute("String", :validity, "validity")
   attribute("String", :validation_message, "validationMessage")
   attribute("List", :labels, "labels")
   attribute("Fixnum", :selection_start, "selectionStart")
   attribute("Fixnum", :selection_end, "selectionEnd")
   attribute("String", :selection_direction, "selectionDirection")
 end
 class InputCollection < ElementCollection
   def element_class
     Input
   end
 end
 class Input < HTMLElement
   attribute("String", :align, "align")
   attribute("String", :use_map, "useMap")
 end
 # do nothing
 class Label < HTMLElement
   attribute("HTMLElement", :form, "form")
   attribute("String", :for, "htmlFor")
   attribute("HTMLElement", :control, "control")
 end
 class LabelCollection < ElementCollection
   def element_class
     Label
   end
 end
 class Form < HTMLElement
   attribute("String", :accept_charset, "acceptCharset")
   attribute("String", :action, "action")
   attribute("String", :autocomplete, "autocomplete")
   attribute("String", :enctype, "enctype")
   attribute("String", :encoding, "encoding")
   attribute("String", :method, "method")
   attribute("String", :name, "name")
   attribute("Boolean", :no_validate?, "noValidate")
   attribute("String", :target, "target")
   attribute("HTMLCollection", :elements, "elements")
   attribute("Fixnum", :length, "length")
 end
 class FormCollection < ElementCollection
   def element_class
     Form
   end
 end
 class TableCell < HTMLElement
   attribute("Fixnum", :col_span, "colSpan")
   attribute("Fixnum", :row_span, "rowSpan")
   attribute("TokenList", :headers, "headers")
   attribute("Fixnum", :cell_index, "cellIndex")
 end
 class TableCellCollection < ElementCollection
   def element_class
     TableCell
   end
 end
 class TableCell < HTMLElement
   attribute("String", :align, "align")
   attribute("String", :axis, "axis")
   attribute("String", :height, "height")
   attribute("String", :width, "width")
   attribute("String", :ch, "ch")
   attribute("String", :ch_off, "chOff")
   attribute("Boolean", :no_wrap?, "noWrap")
   attribute("String", :v_align, "vAlign")
   attribute("String", :bg_color, "bgColor")
 end
 # do nothing
 class TableHeaderCell < TableCell
   attribute("String", :scope, "scope")
   attribute("String", :abbr, "abbr")
   attribute("String", :sorted, "sorted")
 end
 class TableHeaderCellCollection < ElementCollection
   def element_class
     TableHeaderCell
   end
 end
 class TableDataCell < TableCell
 end
 class TableDataCellCollection < ElementCollection
   def element_class
     TableDataCell
   end
 end
 class TableDataCell < TableCell
   attribute("String", :abbr, "abbr")
 end
 # do nothing
 class TableRow < HTMLElement
   attribute("Fixnum", :row_index, "rowIndex")
   attribute("Fixnum", :section_row_index, "sectionRowIndex")
   attribute("HTMLCollection", :cells, "cells")
 end
 class TableRowCollection < ElementCollection
   def element_class
     TableRow
   end
 end
 class TableRow < HTMLElement
   attribute("String", :align, "align")
   attribute("String", :ch, "ch")
   attribute("String", :ch_off, "chOff")
   attribute("String", :v_align, "vAlign")
   attribute("String", :bg_color, "bgColor")
 end
 # do nothing
 class TableSection < HTMLElement
   attribute("HTMLCollection", :rows, "rows")
 end
 class TableSectionCollection < ElementCollection
   def element_class
     TableSection
   end
 end
 class TableSection < HTMLElement
   attribute("String", :align, "align")
   attribute("String", :ch, "ch")
   attribute("String", :ch_off, "chOff")
   attribute("String", :v_align, "vAlign")
 end
 # do nothing
 class TableCol < HTMLElement
   attribute("Fixnum", :span, "span")
 end
 class TableColCollection < ElementCollection
   def element_class
     TableCol
   end
 end
 class TableCol < HTMLElement
   attribute("String", :align, "align")
   attribute("String", :ch, "ch")
   attribute("String", :ch_off, "chOff")
   attribute("String", :v_align, "vAlign")
   attribute("String", :width, "width")
 end
 # do nothing
 class TableCaption < HTMLElement
 end
 class TableCaptionCollection < ElementCollection
   def element_class
     TableCaption
   end
 end
 class TableCaption < HTMLElement
   attribute("String", :align, "align")
 end
 # do nothing
 class Table < HTMLElement
   attribute("HTMLElement", :caption, "caption")
   attribute("HTMLElement", :t_head, "tHead")
   attribute("HTMLElement", :t_foot, "tFoot")
   attribute("HTMLCollection", :t_bodies, "tBodies")
   attribute("HTMLCollection", :rows, "rows")
   attribute("Boolean", :sortable?, "sortable")
 end
 class TableCollection < ElementCollection
   def element_class
     Table
   end
 end
 class Table < HTMLElement
   attribute("String", :align, "align")
   attribute("String", :border, "border")
   attribute("String", :frame, "frame")
   attribute("String", :rules, "rules")
   attribute("String", :summary, "summary")
   attribute("String", :width, "width")
   attribute("String", :bg_color, "bgColor")
   attribute("String", :cell_padding, "cellPadding")
   attribute("String", :cell_spacing, "cellSpacing")
 end
 # do nothing
 class Area < HTMLElement
   attribute("String", :alt, "alt")
   attribute("String", :coords, "coords")
   attribute("String", :shape, "shape")
   attribute("String", :target, "target")
   attribute("String", :download, "download")
   attribute("TokenList", :ping, "ping")
   attribute("String", :rel, "rel")
   attribute("TokenList", :rel_list, "relList")
   attribute("String", :hreflang, "hreflang")
   attribute("String", :type, "type")
 end
 class AreaCollection < ElementCollection
   def element_class
     Area
   end
 end
 class Area < HTMLElement
   attribute("Boolean", :no_href?, "noHref")
 end
 # do nothing
 class Map < HTMLElement
   attribute("String", :name, "name")
   attribute("HTMLCollection", :areas, "areas")
   attribute("HTMLCollection", :images, "images")
 end
 class MapCollection < ElementCollection
   def element_class
     Map
   end
 end
 class Media < HTMLElement
   attribute("String", :error, "error")
   attribute("String", :src, "src")
   attribute("String", :current_src, "currentSrc")
   attribute("String", :cross_origin, "crossOrigin")
   attribute("Fixnum", :network_state, "networkState")
   attribute("String", :preload, "preload")
   attribute("String", :buffered, "buffered")
   attribute("Fixnum", :ready_state, "readyState")
   attribute("Boolean", :seeking?, "seeking")
   attribute("Float", :current_time, "currentTime")
   attribute("Float", :duration, "duration")
   attribute("Boolean", :paused?, "paused")
   attribute("Float", :default_playback_rate, "defaultPlaybackRate")
   attribute("Float", :playback_rate, "playbackRate")
   attribute("String", :played, "played")
   attribute("String", :seekable, "seekable")
   attribute("Boolean", :ended?, "ended")
   attribute("Boolean", :autoplay?, "autoplay")
   attribute("Boolean", :loop?, "loop")
   attribute("String", :media_group, "mediaGroup")
   attribute("String", :controller, "controller")
   attribute("Boolean", :controls?, "controls")
   attribute("Float", :volume, "volume")
   attribute("Boolean", :muted?, "muted")
   attribute("Boolean", :default_muted?, "defaultMuted")
   attribute("List", :audio_tracks, "audioTracks")
   attribute("List", :video_tracks, "videoTracks")
   attribute("List", :text_tracks, "textTracks")
 end
 class MediaCollection < ElementCollection
   def element_class
     Media
   end
 end
 class Audio < Media
 end
 class AudioCollection < ElementCollection
   def element_class
     Audio
   end
 end
 class Video < Media
   attribute("Fixnum", :width, "width")
   attribute("Fixnum", :height, "height")
   attribute("Fixnum", :video_width, "videoWidth")
   attribute("Fixnum", :video_height, "videoHeight")
   attribute("String", :poster, "poster")
 end
 class VideoCollection < ElementCollection
   def element_class
     Video
   end
 end
 class Track < HTMLElement
   attribute("String", :kind, "kind")
   attribute("String", :src, "src")
   attribute("String", :srclang, "srclang")
   attribute("String", :label, "label")
   attribute("Boolean", :default?, "default")
   attribute("Fixnum", :ready_state, "readyState")
   attribute("String", :track, "track")
 end
 class TrackCollection < ElementCollection
   def element_class
     Track
   end
 end
 class Source < HTMLElement
   attribute("String", :src, "src")
   attribute("String", :type, "type")
 end
 class SourceCollection < ElementCollection
   def element_class
     Source
   end
 end
 class Param < HTMLElement
   attribute("String", :name, "name")
   attribute("String", :value, "value")
 end
 class ParamCollection < ElementCollection
   def element_class
     Param
   end
 end
 class Param < HTMLElement
   attribute("String", :type, "type")
   attribute("String", :value_type, "valueType")
 end
 # do nothing
 class Object < HTMLElement
   attribute("String", :data, "data")
   attribute("String", :type, "type")
   attribute("Boolean", :type_must_match?, "typeMustMatch")
   attribute("String", :name, "name")
   attribute("String", :use_map, "useMap")
   attribute("HTMLElement", :form, "form")
   attribute("String", :width, "width")
   attribute("String", :height, "height")
   attribute("Document", :content_document, "contentDocument")
   attribute("String", :content_window, "contentWindow")
   attribute("Boolean", :will_validate?, "willValidate")
   attribute("String", :validity, "validity")
   attribute("String", :validation_message, "validationMessage")
 end
 class ObjectCollection < ElementCollection
   def element_class
     Object
   end
 end
 class Object < HTMLElement
   attribute("String", :align, "align")
   attribute("String", :archive, "archive")
   attribute("String", :code, "code")
   attribute("Boolean", :declare?, "declare")
   attribute("Fixnum", :hspace, "hspace")
   attribute("String", :standby, "standby")
   attribute("Fixnum", :vspace, "vspace")
   attribute("String", :code_base, "codeBase")
   attribute("String", :code_type, "codeType")
   attribute("String", :border, "border")
 end
 # do nothing
 class Embed < HTMLElement
   attribute("String", :src, "src")
   attribute("String", :type, "type")
   attribute("String", :width, "width")
   attribute("String", :height, "height")
 end
 class EmbedCollection < ElementCollection
   def element_class
     Embed
   end
 end
 class Embed < HTMLElement
   attribute("String", :align, "align")
   attribute("String", :name, "name")
 end
 # do nothing
 class IFrame < HTMLElement
   attribute("String", :src, "src")
   attribute("String", :srcdoc, "srcdoc")
   attribute("String", :name, "name")
   attribute("TokenList", :sandbox, "sandbox")
   attribute("Boolean", :seamless?, "seamless")
   attribute("Boolean", :allow_fullscreen?, "allowFullscreen")
   attribute("String", :width, "width")
   attribute("String", :height, "height")
   attribute("Document", :content_document, "contentDocument")
   attribute("String", :content_window, "contentWindow")
 end
 class IFrameCollection < ElementCollection
   def element_class
     IFrame
   end
 end
 class IFrame < HTMLElement
   attribute("String", :align, "align")
   attribute("String", :scrolling, "scrolling")
   attribute("String", :frame_border, "frameBorder")
   attribute("String", :long_desc, "longDesc")
   attribute("String", :margin_height, "marginHeight")
   attribute("String", :margin_width, "marginWidth")
 end
 # do nothing
 class Image < HTMLElement
   attribute("String", :alt, "alt")
   attribute("String", :src, "src")
   attribute("String", :srcset, "srcset")
   attribute("String", :cross_origin, "crossOrigin")
   attribute("String", :use_map, "useMap")
   attribute("Boolean", :map?, "isMap")
   attribute("Fixnum", :width, "width")
   attribute("Fixnum", :height, "height")
   attribute("Fixnum", :natural_width, "naturalWidth")
   attribute("Fixnum", :natural_height, "naturalHeight")
   attribute("Boolean", :complete?, "complete")
 end
 class ImageCollection < ElementCollection
   def element_class
     Image
   end
 end
 class Image < HTMLElement
   attribute("String", :name, "name")
   attribute("String", :lowsrc, "lowsrc")
   attribute("String", :align, "align")
   attribute("Fixnum", :hspace, "hspace")
   attribute("Fixnum", :vspace, "vspace")
   attribute("String", :long_desc, "longDesc")
   attribute("String", :border, "border")
 end
 # do nothing
 class Mod < HTMLElement
   attribute("String", :cite, "cite")
   attribute("String", :date_time, "dateTime")
 end
 class ModCollection < ElementCollection
   def element_class
     Mod
   end
 end
 class BR < HTMLElement
 end
 class BRCollection < ElementCollection
   def element_class
     BR
   end
 end
 class BR < HTMLElement
   attribute("String", :clear, "clear")
 end
 # do nothing
 class Span < HTMLElement
 end
 class SpanCollection < ElementCollection
   def element_class
     Span
   end
 end
 class Time < HTMLElement
   attribute("String", :date_time, "dateTime")
 end
 class TimeCollection < ElementCollection
   def element_class
     Time
   end
 end
 class Data < HTMLElement
   attribute("String", :value, "value")
 end
 class DataCollection < ElementCollection
   def element_class
     Data
   end
 end
 class Anchor < HTMLElement
   attribute("String", :target, "target")
   attribute("String", :download, "download")
   attribute("TokenList", :ping, "ping")
   attribute("String", :rel, "rel")
   attribute("TokenList", :rel_list, "relList")
   attribute("String", :hreflang, "hreflang")
   attribute("String", :type, "type")
   attribute("String", :text, "text")
 end
 class AnchorCollection < ElementCollection
   def element_class
     Anchor
   end
 end
 class Anchor < HTMLElement
   attribute("String", :coords, "coords")
   attribute("String", :charset, "charset")
   attribute("String", :name, "name")
   attribute("String", :rev, "rev")
   attribute("String", :shape, "shape")
 end
 # do nothing
 class Div < HTMLElement
 end
 class DivCollection < ElementCollection
   def element_class
     Div
   end
 end
 class Div < HTMLElement
   attribute("String", :align, "align")
 end
 # do nothing
 class DList < HTMLElement
 end
 class DListCollection < ElementCollection
   def element_class
     DList
   end
 end
 class DList < HTMLElement
   attribute("Boolean", :compact?, "compact")
 end
 # do nothing
 class LI < HTMLElement
   attribute("Fixnum", :value, "value")
 end
 class LICollection < ElementCollection
   def element_class
     LI
   end
 end
 class LI < HTMLElement
   attribute("String", :type, "type")
 end
 # do nothing
 class UList < HTMLElement
 end
 class UListCollection < ElementCollection
   def element_class
     UList
   end
 end
 class UList < HTMLElement
   attribute("Boolean", :compact?, "compact")
   attribute("String", :type, "type")
 end
 # do nothing
 class OList < HTMLElement
   attribute("Boolean", :reversed?, "reversed")
   attribute("Fixnum", :start, "start")
   attribute("String", :type, "type")
 end
 class OListCollection < ElementCollection
   def element_class
     OList
   end
 end
 class OList < HTMLElement
   attribute("Boolean", :compact?, "compact")
 end
 # do nothing
 class Quote < HTMLElement
   attribute("String", :cite, "cite")
 end
 class QuoteCollection < ElementCollection
   def element_class
     Quote
   end
 end
 class Pre < HTMLElement
 end
 class PreCollection < ElementCollection
   def element_class
     Pre
   end
 end
 class Pre < HTMLElement
   attribute("Fixnum", :width, "width")
 end
 # do nothing
 class HR < HTMLElement
 end
 class HRCollection < ElementCollection
   def element_class
     HR
   end
 end
 class HR < HTMLElement
   attribute("String", :align, "align")
   attribute("String", :color, "color")
   attribute("Boolean", :no_shade?, "noShade")
   attribute("String", :size, "size")
   attribute("String", :width, "width")
 end
 # do nothing
 class Paragraph < HTMLElement
 end
 class ParagraphCollection < ElementCollection
   def element_class
     Paragraph
   end
 end
 class Paragraph < HTMLElement
   attribute("String", :align, "align")
 end
 # do nothing
 class Heading < HTMLElement
 end
 class HeadingCollection < ElementCollection
   def element_class
     Heading
   end
 end
 class Heading < HTMLElement
   attribute("String", :align, "align")
 end
 # do nothing
 class Body < HTMLElement
   attribute("Function", :onafterprint, "onafterprint")
   attribute("Function", :onbeforeprint, "onbeforeprint")
   attribute("Function", :onbeforeunload, "onbeforeunload")
   attribute("Function", :onhashchange, "onhashchange")
   attribute("Function", :onlanguagechange, "onlanguagechange")
   attribute("Function", :onmessage, "onmessage")
   attribute("Function", :onoffline, "onoffline")
   attribute("Function", :ononline, "ononline")
   attribute("Function", :onpagehide, "onpagehide")
   attribute("Function", :onpageshow, "onpageshow")
   attribute("Function", :onpopstate, "onpopstate")
   attribute("Function", :onstorage, "onstorage")
   attribute("Function", :onunload, "onunload")
 end
 class BodyCollection < ElementCollection
   def element_class
     Body
   end
 end
 class Body < HTMLElement
   attribute("String", :text, "text")
   attribute("String", :link, "link")
   attribute("String", :v_link, "vLink")
   attribute("String", :a_link, "aLink")
   attribute("String", :bg_color, "bgColor")
   attribute("String", :background, "background")
 end
 # do nothing
 class Style < HTMLElement
   attribute("String", :media, "media")
   attribute("String", :type, "type")
   attribute("Boolean", :scoped?, "scoped")
 end
 class StyleCollection < ElementCollection
   def element_class
     Style
   end
 end
 class Meta < HTMLElement
   attribute("String", :name, "name")
   attribute("String", :http_equiv, "httpEquiv")
   attribute("String", :content, "content")
 end
 class MetaCollection < ElementCollection
   def element_class
     Meta
   end
 end
 class Meta < HTMLElement
   attribute("String", :scheme, "scheme")
 end
 # do nothing
 class Base < HTMLElement
   attribute("String", :href, "href")
   attribute("String", :target, "target")
 end
 class BaseCollection < ElementCollection
   def element_class
     Base
   end
 end
 class Title < HTMLElement
   attribute("String", :text, "text")
 end
 class TitleCollection < ElementCollection
   def element_class
     Title
   end
 end
 class Head < HTMLElement
 end
 class HeadCollection < ElementCollection
   def element_class
     Head
   end
 end
 class Html < HTMLElement
 end
 class HtmlCollection < ElementCollection
   def element_class
     Html
   end
 end
 class Html < HTMLElement
   attribute("String", :version, "version")
 end
 # do nothing
 class Unknown < HTMLElement
 end
 class UnknownCollection < ElementCollection
   def element_class
     Unknown
   end
 end


 module Container

   #
   # @return [Anchor]
   #

   def a(*args)
     Anchor.new(self, extract_selector(args).merge(:tag_name => "a"))
   end

   #
   # @return [AnchorCollection]
   #

   def as(*args)
     AnchorCollection.new(self, extract_selector(args).merge(:tag_name => "a"))
   end

   Watir.tag_to_class[:a] = Anchor

   #
   # @return [HTMLElement]
   #

   def abbr(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "abbr"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def abbrs(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "abbr"))
   end

   Watir.tag_to_class[:abbr] = HTMLElement

   #
   # @return [HTMLElement]
   #

   def address(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "address"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def addresses(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "address"))
   end

   Watir.tag_to_class[:address] = HTMLElement

   #
   # @return [Area]
   #

   def area(*args)
     Area.new(self, extract_selector(args).merge(:tag_name => "area"))
   end

   #
   # @return [AreaCollection]
   #

   def areas(*args)
     AreaCollection.new(self, extract_selector(args).merge(:tag_name => "area"))
   end

   Watir.tag_to_class[:area] = Area

   #
   # @return [HTMLElement]
   #

   def article(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "article"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def articles(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "article"))
   end

   Watir.tag_to_class[:article] = HTMLElement

   #
   # @return [HTMLElement]
   #

   def aside(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "aside"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def asides(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "aside"))
   end

   Watir.tag_to_class[:aside] = HTMLElement

   #
   # @return [Audio]
   #

   def audio(*args)
     Audio.new(self, extract_selector(args).merge(:tag_name => "audio"))
   end

   #
   # @return [AudioCollection]
   #

   def audios(*args)
     AudioCollection.new(self, extract_selector(args).merge(:tag_name => "audio"))
   end

   Watir.tag_to_class[:audio] = Audio

   #
   # @return [HTMLElement]
   #

   def b(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "b"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def bs(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "b"))
   end

   Watir.tag_to_class[:b] = HTMLElement

   #
   # @return [Base]
   #

   def base(*args)
     Base.new(self, extract_selector(args).merge(:tag_name => "base"))
   end

   #
   # @return [BaseCollection]
   #

   def bases(*args)
     BaseCollection.new(self, extract_selector(args).merge(:tag_name => "base"))
   end

   Watir.tag_to_class[:base] = Base

   #
   # @return [HTMLElement]
   #

   def bdi(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "bdi"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def bdis(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "bdi"))
   end

   Watir.tag_to_class[:bdi] = HTMLElement

   #
   # @return [HTMLElement]
   #

   def bdo(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "bdo"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def bdos(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "bdo"))
   end

   Watir.tag_to_class[:bdo] = HTMLElement

   #
   # @return [Quote]
   #

   def blockquote(*args)
     Quote.new(self, extract_selector(args).merge(:tag_name => "blockquote"))
   end

   #
   # @return [QuoteCollection]
   #

   def blockquotes(*args)
     QuoteCollection.new(self, extract_selector(args).merge(:tag_name => "blockquote"))
   end

   Watir.tag_to_class[:blockquote] = Quote

   #
   # @return [Body]
   #

   def body(*args)
     Body.new(self, extract_selector(args).merge(:tag_name => "body"))
   end

   #
   # @return [BodyCollection]
   #

   def bodys(*args)
     BodyCollection.new(self, extract_selector(args).merge(:tag_name => "body"))
   end

   Watir.tag_to_class[:body] = Body

   #
   # @return [BR]
   #

   def br(*args)
     BR.new(self, extract_selector(args).merge(:tag_name => "br"))
   end

   #
   # @return [BRCollection]
   #

   def brs(*args)
     BRCollection.new(self, extract_selector(args).merge(:tag_name => "br"))
   end

   Watir.tag_to_class[:br] = BR

   #
   # @return [Button]
   #

   def button(*args)
     Button.new(self, extract_selector(args).merge(:tag_name => "button"))
   end

   #
   # @return [ButtonCollection]
   #

   def buttons(*args)
     ButtonCollection.new(self, extract_selector(args).merge(:tag_name => "button"))
   end

   Watir.tag_to_class[:button] = Button

   #
   # @return [Canvas]
   #

   def canvas(*args)
     Canvas.new(self, extract_selector(args).merge(:tag_name => "canvas"))
   end

   #
   # @return [CanvasCollection]
   #

   def canvases(*args)
     CanvasCollection.new(self, extract_selector(args).merge(:tag_name => "canvas"))
   end

   Watir.tag_to_class[:canvas] = Canvas

   #
   # @return [TableCaption]
   #

   def caption(*args)
     TableCaption.new(self, extract_selector(args).merge(:tag_name => "caption"))
   end

   #
   # @return [TableCaptionCollection]
   #

   def captions(*args)
     TableCaptionCollection.new(self, extract_selector(args).merge(:tag_name => "caption"))
   end

   Watir.tag_to_class[:caption] = TableCaption

   #
   # @return [HTMLElement]
   #

   def cite(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "cite"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def cites(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "cite"))
   end

   Watir.tag_to_class[:cite] = HTMLElement

   #
   # @return [HTMLElement]
   #

   def code(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "code"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def codes(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "code"))
   end

   Watir.tag_to_class[:code] = HTMLElement

   #
   # @return [TableCol]
   #

   def col(*args)
     TableCol.new(self, extract_selector(args).merge(:tag_name => "col"))
   end

   #
   # @return [TableColCollection]
   #

   def cols(*args)
     TableColCollection.new(self, extract_selector(args).merge(:tag_name => "col"))
   end

   Watir.tag_to_class[:col] = TableCol

   #
   # @return [TableCol]
   #

   def colgroup(*args)
     TableCol.new(self, extract_selector(args).merge(:tag_name => "colgroup"))
   end

   #
   # @return [TableColCollection]
   #

   def colgroups(*args)
     TableColCollection.new(self, extract_selector(args).merge(:tag_name => "colgroup"))
   end

   Watir.tag_to_class[:colgroup] = TableCol

   #
   # @return [Data]
   #

   def data(*args)
     Data.new(self, extract_selector(args).merge(:tag_name => "data"))
   end

   #
   # @return [DataCollection]
   #

   def datas(*args)
     DataCollection.new(self, extract_selector(args).merge(:tag_name => "data"))
   end

   Watir.tag_to_class[:data] = Data

   #
   # @return [DataList]
   #

   def datalist(*args)
     DataList.new(self, extract_selector(args).merge(:tag_name => "datalist"))
   end

   #
   # @return [DataListCollection]
   #

   def datalists(*args)
     DataListCollection.new(self, extract_selector(args).merge(:tag_name => "datalist"))
   end

   Watir.tag_to_class[:datalist] = DataList

   #
   # @return [HTMLElement]
   #

   def dd(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "dd"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def dds(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "dd"))
   end

   Watir.tag_to_class[:dd] = HTMLElement

   #
   # @return [Mod]
   #

   def del(*args)
     Mod.new(self, extract_selector(args).merge(:tag_name => "del"))
   end

   #
   # @return [ModCollection]
   #

   def dels(*args)
     ModCollection.new(self, extract_selector(args).merge(:tag_name => "del"))
   end

   Watir.tag_to_class[:del] = Mod

   #
   # @return [Details]
   #

   def details(*args)
     Details.new(self, extract_selector(args).merge(:tag_name => "details"))
   end

   #
   # @return [DetailsCollection]
   #

   def detailses(*args)
     DetailsCollection.new(self, extract_selector(args).merge(:tag_name => "details"))
   end

   Watir.tag_to_class[:details] = Details

   #
   # @return [HTMLElement]
   #

   def dfn(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "dfn"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def dfns(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "dfn"))
   end

   Watir.tag_to_class[:dfn] = HTMLElement

   #
   # @return [Dialog]
   #

   def dialog(*args)
     Dialog.new(self, extract_selector(args).merge(:tag_name => "dialog"))
   end

   #
   # @return [DialogCollection]
   #

   def dialogs(*args)
     DialogCollection.new(self, extract_selector(args).merge(:tag_name => "dialog"))
   end

   Watir.tag_to_class[:dialog] = Dialog

   #
   # @return [Div]
   #

   def div(*args)
     Div.new(self, extract_selector(args).merge(:tag_name => "div"))
   end

   #
   # @return [DivCollection]
   #

   def divs(*args)
     DivCollection.new(self, extract_selector(args).merge(:tag_name => "div"))
   end

   Watir.tag_to_class[:div] = Div

   #
   # @return [DList]
   #

   def dl(*args)
     DList.new(self, extract_selector(args).merge(:tag_name => "dl"))
   end

   #
   # @return [DListCollection]
   #

   def dls(*args)
     DListCollection.new(self, extract_selector(args).merge(:tag_name => "dl"))
   end

   Watir.tag_to_class[:dl] = DList

   #
   # @return [HTMLElement]
   #

   def dt(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "dt"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def dts(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "dt"))
   end

   Watir.tag_to_class[:dt] = HTMLElement

   #
   # @return [HTMLElement]
   #

   def em(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "em"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def ems(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "em"))
   end

   Watir.tag_to_class[:em] = HTMLElement

   #
   # @return [Embed]
   #

   def embed(*args)
     Embed.new(self, extract_selector(args).merge(:tag_name => "embed"))
   end

   #
   # @return [EmbedCollection]
   #

   def embeds(*args)
     EmbedCollection.new(self, extract_selector(args).merge(:tag_name => "embed"))
   end

   Watir.tag_to_class[:embed] = Embed

   #
   # @return [FieldSet]
   #

   def fieldset(*args)
     FieldSet.new(self, extract_selector(args).merge(:tag_name => "fieldset"))
   end

   #
   # @return [FieldSetCollection]
   #

   def fieldsets(*args)
     FieldSetCollection.new(self, extract_selector(args).merge(:tag_name => "fieldset"))
   end

   Watir.tag_to_class[:fieldset] = FieldSet

   #
   # @return [HTMLElement]
   #

   def figcaption(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "figcaption"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def figcaptions(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "figcaption"))
   end

   Watir.tag_to_class[:figcaption] = HTMLElement

   #
   # @return [HTMLElement]
   #

   def figure(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "figure"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def figures(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "figure"))
   end

   Watir.tag_to_class[:figure] = HTMLElement

   #
   # @return [HTMLElement]
   #

   def footer(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "footer"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def footers(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "footer"))
   end

   Watir.tag_to_class[:footer] = HTMLElement

   #
   # @return [Form]
   #

   def form(*args)
     Form.new(self, extract_selector(args).merge(:tag_name => "form"))
   end

   #
   # @return [FormCollection]
   #

   def forms(*args)
     FormCollection.new(self, extract_selector(args).merge(:tag_name => "form"))
   end

   Watir.tag_to_class[:form] = Form

   #
   # @return [FrameSet]
   #

   def frameset(*args)
     FrameSet.new(self, extract_selector(args).merge(:tag_name => "frameset"))
   end

   #
   # @return [FrameSetCollection]
   #

   def framesets(*args)
     FrameSetCollection.new(self, extract_selector(args).merge(:tag_name => "frameset"))
   end

   Watir.tag_to_class[:frameset] = FrameSet

   #
   # @return [Heading]
   #

   def h1(*args)
     Heading.new(self, extract_selector(args).merge(:tag_name => "h1"))
   end

   #
   # @return [HeadingCollection]
   #

   def h1s(*args)
     HeadingCollection.new(self, extract_selector(args).merge(:tag_name => "h1"))
   end

   Watir.tag_to_class[:h1] = Heading

   #
   # @return [Heading]
   #

   def h2(*args)
     Heading.new(self, extract_selector(args).merge(:tag_name => "h2"))
   end

   #
   # @return [HeadingCollection]
   #

   def h2s(*args)
     HeadingCollection.new(self, extract_selector(args).merge(:tag_name => "h2"))
   end

   Watir.tag_to_class[:h2] = Heading

   #
   # @return [Heading]
   #

   def h3(*args)
     Heading.new(self, extract_selector(args).merge(:tag_name => "h3"))
   end

   #
   # @return [HeadingCollection]
   #

   def h3s(*args)
     HeadingCollection.new(self, extract_selector(args).merge(:tag_name => "h3"))
   end

   Watir.tag_to_class[:h3] = Heading

   #
   # @return [Heading]
   #

   def h4(*args)
     Heading.new(self, extract_selector(args).merge(:tag_name => "h4"))
   end

   #
   # @return [HeadingCollection]
   #

   def h4s(*args)
     HeadingCollection.new(self, extract_selector(args).merge(:tag_name => "h4"))
   end

   Watir.tag_to_class[:h4] = Heading

   #
   # @return [Heading]
   #

   def h5(*args)
     Heading.new(self, extract_selector(args).merge(:tag_name => "h5"))
   end

   #
   # @return [HeadingCollection]
   #

   def h5s(*args)
     HeadingCollection.new(self, extract_selector(args).merge(:tag_name => "h5"))
   end

   Watir.tag_to_class[:h5] = Heading

   #
   # @return [Heading]
   #

   def h6(*args)
     Heading.new(self, extract_selector(args).merge(:tag_name => "h6"))
   end

   #
   # @return [HeadingCollection]
   #

   def h6s(*args)
     HeadingCollection.new(self, extract_selector(args).merge(:tag_name => "h6"))
   end

   Watir.tag_to_class[:h6] = Heading

   #
   # @return [Head]
   #

   def head(*args)
     Head.new(self, extract_selector(args).merge(:tag_name => "head"))
   end

   #
   # @return [HeadCollection]
   #

   def heads(*args)
     HeadCollection.new(self, extract_selector(args).merge(:tag_name => "head"))
   end

   Watir.tag_to_class[:head] = Head

   #
   # @return [HTMLElement]
   #

   def header(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "header"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def headers(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "header"))
   end

   Watir.tag_to_class[:header] = HTMLElement

   #
   # @return [HTMLElement]
   #

   def hgroup(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "hgroup"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def hgroups(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "hgroup"))
   end

   Watir.tag_to_class[:hgroup] = HTMLElement

   #
   # @return [HR]
   #

   def hr(*args)
     HR.new(self, extract_selector(args).merge(:tag_name => "hr"))
   end

   #
   # @return [HRCollection]
   #

   def hrs(*args)
     HRCollection.new(self, extract_selector(args).merge(:tag_name => "hr"))
   end

   Watir.tag_to_class[:hr] = HR

   #
   # @return [Html]
   #

   def html(*args)
     Html.new(self, extract_selector(args).merge(:tag_name => "html"))
   end

   #
   # @return [HtmlCollection]
   #

   def htmls(*args)
     HtmlCollection.new(self, extract_selector(args).merge(:tag_name => "html"))
   end

   Watir.tag_to_class[:html] = Html

   #
   # @return [HTMLElement]
   #

   def i(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "i"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def is(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "i"))
   end

   Watir.tag_to_class[:i] = HTMLElement

   #
   # @return [IFrame]
   #

   def iframe(*args)
     IFrame.new(self, extract_selector(args).merge(:tag_name => "iframe"))
   end

   #
   # @return [IFrameCollection]
   #

   def iframes(*args)
     IFrameCollection.new(self, extract_selector(args).merge(:tag_name => "iframe"))
   end

   Watir.tag_to_class[:iframe] = IFrame

   #
   # @return [Image]
   #

   def img(*args)
     Image.new(self, extract_selector(args).merge(:tag_name => "img"))
   end

   #
   # @return [ImageCollection]
   #

   def imgs(*args)
     ImageCollection.new(self, extract_selector(args).merge(:tag_name => "img"))
   end

   Watir.tag_to_class[:img] = Image

   #
   # @return [Input]
   #

   def input(*args)
     Input.new(self, extract_selector(args).merge(:tag_name => "input"))
   end

   #
   # @return [InputCollection]
   #

   def inputs(*args)
     InputCollection.new(self, extract_selector(args).merge(:tag_name => "input"))
   end

   Watir.tag_to_class[:input] = Input

   #
   # @return [Mod]
   #

   def ins(*args)
     Mod.new(self, extract_selector(args).merge(:tag_name => "ins"))
   end

   #
   # @return [ModCollection]
   #

   def inses(*args)
     ModCollection.new(self, extract_selector(args).merge(:tag_name => "ins"))
   end

   Watir.tag_to_class[:ins] = Mod

   #
   # @return [HTMLElement]
   #

   def kbd(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "kbd"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def kbds(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "kbd"))
   end

   Watir.tag_to_class[:kbd] = HTMLElement

   #
   # @return [Keygen]
   #

   def keygen(*args)
     Keygen.new(self, extract_selector(args).merge(:tag_name => "keygen"))
   end

   #
   # @return [KeygenCollection]
   #

   def keygens(*args)
     KeygenCollection.new(self, extract_selector(args).merge(:tag_name => "keygen"))
   end

   Watir.tag_to_class[:keygen] = Keygen

   #
   # @return [Label]
   #

   def label(*args)
     Label.new(self, extract_selector(args).merge(:tag_name => "label"))
   end

   #
   # @return [LabelCollection]
   #

   def labels(*args)
     LabelCollection.new(self, extract_selector(args).merge(:tag_name => "label"))
   end

   Watir.tag_to_class[:label] = Label

   #
   # @return [Legend]
   #

   def legend(*args)
     Legend.new(self, extract_selector(args).merge(:tag_name => "legend"))
   end

   #
   # @return [LegendCollection]
   #

   def legends(*args)
     LegendCollection.new(self, extract_selector(args).merge(:tag_name => "legend"))
   end

   Watir.tag_to_class[:legend] = Legend

   #
   # @return [LI]
   #

   def li(*args)
     LI.new(self, extract_selector(args).merge(:tag_name => "li"))
   end

   #
   # @return [LICollection]
   #

   def lis(*args)
     LICollection.new(self, extract_selector(args).merge(:tag_name => "li"))
   end

   Watir.tag_to_class[:li] = LI

   #
   # @return [HTMLElement]
   #

   def main(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "main"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def mains(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "main"))
   end

   Watir.tag_to_class[:main] = HTMLElement

   #
   # @return [Map]
   #

   def map(*args)
     Map.new(self, extract_selector(args).merge(:tag_name => "map"))
   end

   #
   # @return [MapCollection]
   #

   def maps(*args)
     MapCollection.new(self, extract_selector(args).merge(:tag_name => "map"))
   end

   Watir.tag_to_class[:map] = Map

   #
   # @return [HTMLElement]
   #

   def mark(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "mark"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def marks(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "mark"))
   end

   Watir.tag_to_class[:mark] = HTMLElement

   #
   # @return [Menu]
   #

   def menu(*args)
     Menu.new(self, extract_selector(args).merge(:tag_name => "menu"))
   end

   #
   # @return [MenuCollection]
   #

   def menus(*args)
     MenuCollection.new(self, extract_selector(args).merge(:tag_name => "menu"))
   end

   Watir.tag_to_class[:menu] = Menu

   #
   # @return [MenuItem]
   #

   def menuitem(*args)
     MenuItem.new(self, extract_selector(args).merge(:tag_name => "menuitem"))
   end

   #
   # @return [MenuItemCollection]
   #

   def menuitems(*args)
     MenuItemCollection.new(self, extract_selector(args).merge(:tag_name => "menuitem"))
   end

   Watir.tag_to_class[:menuitem] = MenuItem

   #
   # @return [Meta]
   #

   def meta(*args)
     Meta.new(self, extract_selector(args).merge(:tag_name => "meta"))
   end

   #
   # @return [MetaCollection]
   #

   def metas(*args)
     MetaCollection.new(self, extract_selector(args).merge(:tag_name => "meta"))
   end

   Watir.tag_to_class[:meta] = Meta

   #
   # @return [Meter]
   #

   def meter(*args)
     Meter.new(self, extract_selector(args).merge(:tag_name => "meter"))
   end

   #
   # @return [MeterCollection]
   #

   def meters(*args)
     MeterCollection.new(self, extract_selector(args).merge(:tag_name => "meter"))
   end

   Watir.tag_to_class[:meter] = Meter

   #
   # @return [HTMLElement]
   #

   def nav(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "nav"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def navs(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "nav"))
   end

   Watir.tag_to_class[:nav] = HTMLElement

   #
   # @return [HTMLElement]
   #

   def noscript(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "noscript"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def noscripts(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "noscript"))
   end

   Watir.tag_to_class[:noscript] = HTMLElement

   #
   # @return [Object]
   #

   def object(*args)
     Object.new(self, extract_selector(args).merge(:tag_name => "object"))
   end

   #
   # @return [ObjectCollection]
   #

   def objects(*args)
     ObjectCollection.new(self, extract_selector(args).merge(:tag_name => "object"))
   end

   Watir.tag_to_class[:object] = Object

   #
   # @return [OList]
   #

   def ol(*args)
     OList.new(self, extract_selector(args).merge(:tag_name => "ol"))
   end

   #
   # @return [OListCollection]
   #

   def ols(*args)
     OListCollection.new(self, extract_selector(args).merge(:tag_name => "ol"))
   end

   Watir.tag_to_class[:ol] = OList

   #
   # @return [OptGroup]
   #

   def optgroup(*args)
     OptGroup.new(self, extract_selector(args).merge(:tag_name => "optgroup"))
   end

   #
   # @return [OptGroupCollection]
   #

   def optgroups(*args)
     OptGroupCollection.new(self, extract_selector(args).merge(:tag_name => "optgroup"))
   end

   Watir.tag_to_class[:optgroup] = OptGroup

   #
   # @return [Option]
   #

   def option(*args)
     Option.new(self, extract_selector(args).merge(:tag_name => "option"))
   end

   #
   # @return [OptionCollection]
   #

   def options(*args)
     OptionCollection.new(self, extract_selector(args).merge(:tag_name => "option"))
   end

   Watir.tag_to_class[:option] = Option

   #
   # @return [Output]
   #

   def output(*args)
     Output.new(self, extract_selector(args).merge(:tag_name => "output"))
   end

   #
   # @return [OutputCollection]
   #

   def outputs(*args)
     OutputCollection.new(self, extract_selector(args).merge(:tag_name => "output"))
   end

   Watir.tag_to_class[:output] = Output

   #
   # @return [Paragraph]
   #

   def p(*args)
     Paragraph.new(self, extract_selector(args).merge(:tag_name => "p"))
   end

   #
   # @return [ParagraphCollection]
   #

   def ps(*args)
     ParagraphCollection.new(self, extract_selector(args).merge(:tag_name => "p"))
   end

   Watir.tag_to_class[:p] = Paragraph

   #
   # @return [Param]
   #

   def param(*args)
     Param.new(self, extract_selector(args).merge(:tag_name => "param"))
   end

   #
   # @return [ParamCollection]
   #

   def params(*args)
     ParamCollection.new(self, extract_selector(args).merge(:tag_name => "param"))
   end

   Watir.tag_to_class[:param] = Param

   #
   # @return [Pre]
   #

   def pre(*args)
     Pre.new(self, extract_selector(args).merge(:tag_name => "pre"))
   end

   #
   # @return [PreCollection]
   #

   def pres(*args)
     PreCollection.new(self, extract_selector(args).merge(:tag_name => "pre"))
   end

   Watir.tag_to_class[:pre] = Pre

   #
   # @return [Progress]
   #

   def progress(*args)
     Progress.new(self, extract_selector(args).merge(:tag_name => "progress"))
   end

   #
   # @return [ProgressCollection]
   #

   def progresses(*args)
     ProgressCollection.new(self, extract_selector(args).merge(:tag_name => "progress"))
   end

   Watir.tag_to_class[:progress] = Progress

   #
   # @return [Quote]
   #

   def q(*args)
     Quote.new(self, extract_selector(args).merge(:tag_name => "q"))
   end

   #
   # @return [QuoteCollection]
   #

   def qs(*args)
     QuoteCollection.new(self, extract_selector(args).merge(:tag_name => "q"))
   end

   Watir.tag_to_class[:q] = Quote

   #
   # @return [HTMLElement]
   #

   def rp(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "rp"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def rps(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "rp"))
   end

   Watir.tag_to_class[:rp] = HTMLElement

   #
   # @return [HTMLElement]
   #

   def rt(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "rt"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def rts(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "rt"))
   end

   Watir.tag_to_class[:rt] = HTMLElement

   #
   # @return [HTMLElement]
   #

   def ruby(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "ruby"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def rubies(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "ruby"))
   end

   Watir.tag_to_class[:ruby] = HTMLElement

   #
   # @return [HTMLElement]
   #

   def s(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "s"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def ss(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "s"))
   end

   Watir.tag_to_class[:s] = HTMLElement

   #
   # @return [HTMLElement]
   #

   def samp(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "samp"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def samps(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "samp"))
   end

   Watir.tag_to_class[:samp] = HTMLElement

   #
   # @return [Script]
   #

   def script(*args)
     Script.new(self, extract_selector(args).merge(:tag_name => "script"))
   end

   #
   # @return [ScriptCollection]
   #

   def scripts(*args)
     ScriptCollection.new(self, extract_selector(args).merge(:tag_name => "script"))
   end

   Watir.tag_to_class[:script] = Script

   #
   # @return [HTMLElement]
   #

   def section(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "section"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def sections(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "section"))
   end

   Watir.tag_to_class[:section] = HTMLElement

   #
   # @return [Select]
   #

   def select(*args)
     Select.new(self, extract_selector(args).merge(:tag_name => "select"))
   end

   #
   # @return [SelectCollection]
   #

   def selects(*args)
     SelectCollection.new(self, extract_selector(args).merge(:tag_name => "select"))
   end

   Watir.tag_to_class[:select] = Select

   #
   # @return [HTMLElement]
   #

   def small(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "small"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def smalls(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "small"))
   end

   Watir.tag_to_class[:small] = HTMLElement

   #
   # @return [Source]
   #

   def source(*args)
     Source.new(self, extract_selector(args).merge(:tag_name => "source"))
   end

   #
   # @return [SourceCollection]
   #

   def sources(*args)
     SourceCollection.new(self, extract_selector(args).merge(:tag_name => "source"))
   end

   Watir.tag_to_class[:source] = Source

   #
   # @return [Span]
   #

   def span(*args)
     Span.new(self, extract_selector(args).merge(:tag_name => "span"))
   end

   #
   # @return [SpanCollection]
   #

   def spans(*args)
     SpanCollection.new(self, extract_selector(args).merge(:tag_name => "span"))
   end

   Watir.tag_to_class[:span] = Span

   #
   # @return [HTMLElement]
   #

   def strong(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "strong"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def strongs(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "strong"))
   end

   Watir.tag_to_class[:strong] = HTMLElement

   #
   # @return [Style]
   #

   def style(*args)
     Style.new(self, extract_selector(args).merge(:tag_name => "style"))
   end

   #
   # @return [StyleCollection]
   #

   def styles(*args)
     StyleCollection.new(self, extract_selector(args).merge(:tag_name => "style"))
   end

   Watir.tag_to_class[:style] = Style

   #
   # @return [HTMLElement]
   #

   def sub(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "sub"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def subs(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "sub"))
   end

   Watir.tag_to_class[:sub] = HTMLElement

   #
   # @return [HTMLElement]
   #

   def summary(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "summary"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def summaries(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "summary"))
   end

   Watir.tag_to_class[:summary] = HTMLElement

   #
   # @return [HTMLElement]
   #

   def sup(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "sup"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def sups(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "sup"))
   end

   Watir.tag_to_class[:sup] = HTMLElement

   #
   # @return [Table]
   #

   def table(*args)
     Table.new(self, extract_selector(args).merge(:tag_name => "table"))
   end

   #
   # @return [TableCollection]
   #

   def tables(*args)
     TableCollection.new(self, extract_selector(args).merge(:tag_name => "table"))
   end

   Watir.tag_to_class[:table] = Table

   #
   # @return [TableSection]
   #

   def tbody(*args)
     TableSection.new(self, extract_selector(args).merge(:tag_name => "tbody"))
   end

   #
   # @return [TableSectionCollection]
   #

   def tbodys(*args)
     TableSectionCollection.new(self, extract_selector(args).merge(:tag_name => "tbody"))
   end

   Watir.tag_to_class[:tbody] = TableSection

   #
   # @return [TableDataCell]
   #

   def td(*args)
     TableDataCell.new(self, extract_selector(args).merge(:tag_name => "td"))
   end

   #
   # @return [TableDataCellCollection]
   #

   def tds(*args)
     TableDataCellCollection.new(self, extract_selector(args).merge(:tag_name => "td"))
   end

   Watir.tag_to_class[:td] = TableDataCell

   #
   # @return [Template]
   #

   def template(*args)
     Template.new(self, extract_selector(args).merge(:tag_name => "template"))
   end

   #
   # @return [TemplateCollection]
   #

   def templates(*args)
     TemplateCollection.new(self, extract_selector(args).merge(:tag_name => "template"))
   end

   Watir.tag_to_class[:template] = Template

   #
   # @return [TextArea]
   #

   def textarea(*args)
     TextArea.new(self, extract_selector(args).merge(:tag_name => "textarea"))
   end

   #
   # @return [TextAreaCollection]
   #

   def textareas(*args)
     TextAreaCollection.new(self, extract_selector(args).merge(:tag_name => "textarea"))
   end

   Watir.tag_to_class[:textarea] = TextArea

   #
   # @return [TableSection]
   #

   def tfoot(*args)
     TableSection.new(self, extract_selector(args).merge(:tag_name => "tfoot"))
   end

   #
   # @return [TableSectionCollection]
   #

   def tfoots(*args)
     TableSectionCollection.new(self, extract_selector(args).merge(:tag_name => "tfoot"))
   end

   Watir.tag_to_class[:tfoot] = TableSection

   #
   # @return [TableHeaderCell]
   #

   def th(*args)
     TableHeaderCell.new(self, extract_selector(args).merge(:tag_name => "th"))
   end

   #
   # @return [TableHeaderCellCollection]
   #

   def ths(*args)
     TableHeaderCellCollection.new(self, extract_selector(args).merge(:tag_name => "th"))
   end

   Watir.tag_to_class[:th] = TableHeaderCell

   #
   # @return [TableSection]
   #

   def thead(*args)
     TableSection.new(self, extract_selector(args).merge(:tag_name => "thead"))
   end

   #
   # @return [TableSectionCollection]
   #

   def theads(*args)
     TableSectionCollection.new(self, extract_selector(args).merge(:tag_name => "thead"))
   end

   Watir.tag_to_class[:thead] = TableSection

   #
   # @return [Time]
   #

   def time(*args)
     Time.new(self, extract_selector(args).merge(:tag_name => "time"))
   end

   #
   # @return [TimeCollection]
   #

   def times(*args)
     TimeCollection.new(self, extract_selector(args).merge(:tag_name => "time"))
   end

   Watir.tag_to_class[:time] = Time

   #
   # @return [Title]
   #

   def title(*args)
     Title.new(self, extract_selector(args).merge(:tag_name => "title"))
   end

   #
   # @return [TitleCollection]
   #

   def titles(*args)
     TitleCollection.new(self, extract_selector(args).merge(:tag_name => "title"))
   end

   Watir.tag_to_class[:title] = Title

   #
   # @return [TableRow]
   #

   def tr(*args)
     TableRow.new(self, extract_selector(args).merge(:tag_name => "tr"))
   end

   #
   # @return [TableRowCollection]
   #

   def trs(*args)
     TableRowCollection.new(self, extract_selector(args).merge(:tag_name => "tr"))
   end

   Watir.tag_to_class[:tr] = TableRow

   #
   # @return [Track]
   #

   def track(*args)
     Track.new(self, extract_selector(args).merge(:tag_name => "track"))
   end

   #
   # @return [TrackCollection]
   #

   def tracks(*args)
     TrackCollection.new(self, extract_selector(args).merge(:tag_name => "track"))
   end

   Watir.tag_to_class[:track] = Track

   #
   # @return [HTMLElement]
   #

   def u(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "u"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def us(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "u"))
   end

   Watir.tag_to_class[:u] = HTMLElement

   #
   # @return [UList]
   #

   def ul(*args)
     UList.new(self, extract_selector(args).merge(:tag_name => "ul"))
   end

   #
   # @return [UListCollection]
   #

   def uls(*args)
     UListCollection.new(self, extract_selector(args).merge(:tag_name => "ul"))
   end

   Watir.tag_to_class[:ul] = UList

   #
   # @return [HTMLElement]
   #

   def var(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "var"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def vars(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "var"))
   end

   Watir.tag_to_class[:var] = HTMLElement

   #
   # @return [Video]
   #

   def video(*args)
     Video.new(self, extract_selector(args).merge(:tag_name => "video"))
   end

   #
   # @return [VideoCollection]
   #

   def videos(*args)
     VideoCollection.new(self, extract_selector(args).merge(:tag_name => "video"))
   end

   Watir.tag_to_class[:video] = Video

   #
   # @return [HTMLElement]
   #

   def wbr(*args)
     HTMLElement.new(self, extract_selector(args).merge(:tag_name => "wbr"))
   end

   #
   # @return [HTMLElementCollection]
   #

   def wbrs(*args)
     HTMLElementCollection.new(self, extract_selector(args).merge(:tag_name => "wbr"))
   end

   Watir.tag_to_class[:wbr] = HTMLElement
 end # Container
end # Watir
